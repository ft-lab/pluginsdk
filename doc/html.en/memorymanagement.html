<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Memory Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('memorymanagement.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Memory Management </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="objects"></a>
*Types of Objects</h2>
<p>There are two types of objects that the Shade plugin SDK uses. One is those with class names ending with '_interface' which is reference counted. The other is those with names ending '_class.' Their purpose is to provide plugins access to otherwise opaque Shade objects. Since they are permanently attached to coresponding opaque objectcs, they do not need to be memory-managed.</p>
<h2><a class="anchor" id="refcounting"></a>
*Reference Counting</h2>
<p>All class with names ending '_interfaces' are derived from the 'unknown_interface' class. unknown_class::AddRef() increments the reference count and unknown_class::Release() decrements the reference count.</p>
<p>All SDK functions named 'get_*_interface' or 'create_*_interface' returns an object with AddRef() already called. The receiver must make sure that the corresponding Release() call is made.</p>
<p>Using compointer template class is one way to ensure that Release() is called properly and exception-safely.</p>
<h2><a class="anchor" id="compointer"></a>
*About compointer</h2>
<h3><a class="anchor" id="requiring_compointer"></a>
Situations Requiring compointer</h3>
<div class="fragment"><pre class="fragment"> <span class="comment">// Function that takes a return value of xxx_interface</span>
 xxx_interface *scene_interface::get_xxx_interface(<span class="keywordtype">void</span>* = <span class="keyword">nullptr</span>);
</pre></div><div class="fragment"><pre class="fragment"> <span class="comment">// Acquire with compointer</span>
 <a class="code" href="classcompointer.html" title="A smart pointer for reference counted *_interface classes.">compointer&lt;xxx_interface&gt;</a> xxx (scene-&gt;get_xxx_interface());
 
 <span class="comment">// Acquiring like this leaves a memory leak</span>
 xxx_interface *xxx = scene-&gt;get_xxx_interface();
</pre></div><p>In Shade Plugin SDK, when acquiring the xxx_interface pointer with the function as the return value, use compointer as in the example above. If compointer is not used when handling a standard pointer, the interface memory is not freed, and there is a memory leak. Compointer is the only function that will take xxx_interface as its return value, so all you need to remember is that when acquiring xxx_interface pointer, use compointer.</p>
<h3><a class="anchor" id="not_using_compointer"></a>
Situations Not Requiring compointer</h3>
<div class="fragment"><pre class="fragment"> <span class="comment">// If you acquire like this there will be a memory leak,</span>
 xxx_interface *xxx = scene-&gt;get_xxx_interface();
 <span class="comment">// but if you use Release if will be freed</span>
 xxx-&gt;Release();
</pre></div><div class="fragment"><pre class="fragment"> <span class="comment">// Acquiring like this will leave a memory leak,</span>
 xxx_interface *xxx = scene-&gt;get_xxx_interface();
 <span class="comment">// but by using delete, it will be freed</span>
 <span class="keyword">delete</span> xxx; <span class="comment">// The method is not recommended</span>
</pre></div><p>When acquiring an interface, it is recommended that you use compointer, but it is possible to do without using compointer. One way is to call the Release function for the interface pointer. Another way is to delete the pointer. The method of using the Release function is more direct, while the delete method involves forcing the release of the memory reserved by new. At present, the interface acquires reference counter in the interface has only one state (it is not referenced by any other plugin), even directly deleting the pointer should not cause any problems, but because this method violates the COM (Component Object Model) form that manages the reference counter memory, it is not recommended. </p>
</div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<br><br>
<hr>
<div align="center">Copyright &copy; e frontier, Inc. All rights reserved.</div>
</body></html>
